# 🏗️ Architecture Documentation

This document provides a comprehensive overview of Archon's architecture, design principles, and technical implementation.

## 🎯 Design Philosophy

Archon is built on the following core principles:

- **Microservices Architecture**: Independent, scalable services with clear responsibilities
- **AI-First Design**: Every component is optimized for AI agent integration
- **Real-time Collaboration**: Live updates and seamless multi-user experience
- **Knowledge-Driven Development**: Documentation and knowledge as first-class citizens
- **Extensible Framework**: Plugin architecture for custom agents and integrations

## 🏢 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                  ARCHON ECOSYSTEM                                │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │   AI CLIENTS    │    │   WEB CLIENTS   │    │  ADMIN TOOLS    │             │
│  │                 │    │                 │    │                 │             │
│  │ • Claude Code   │◄──►│ • React UI      │◄──►│ • Monitoring    │             │
│  │ • Cursor        │    │ • Mobile App    │    │ • Analytics     │             │
│  │ • Windsurf      │    │ • Browser Ext.  │    │ • Management    │             │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘             │
│           │                        │                        │                  │
├───────────┼────────────────────────┼────────────────────────┼──────────────────┤\n│           │              HTTP/WS   │               HTTP     │                  │\n│           │                        │                        │                  │\n│  ┌────────▼────────┐     ┌────────▼────────┐     ┌────────▼────────┐        │\n│  │   MCP SERVER    │     │   WEB SERVER    │     │  AGENTS SERVICE │        │\n│  │                 │     │                 │     │                 │        │\n│  │ • Protocol Hub  │     │ • FastAPI Core  │     │ • 21+ AI Agents │        │\n│  │ • Tool Router   │◄───►│ • Socket.IO     │◄───►│ • DeepConf      │        │\n│  │ • Session Mgmt  │     │ • Business      │     │ • SCWT Metrics  │        │\n│  │   Port: 8051    │     │   Logic         │     │   Port: 8052    │        │\n│  └─────────────────┘     │   Port: 8181    │     └─────────────────┘        │\n│                          └─────────────────┘                                 │\n│                                    │                                          │\n│           ┌────────────────────────┼────────────────────────┐                │\n│           │                        │                        │                │\n│  ┌────────▼────────┐     ┌────────▼────────┐     ┌────────▼────────┐        │\n│  │ KNOWLEDGE BASE  │     │   DATA LAYER    │     │ EXTERNAL APIS   │        │\n│  │                 │     │                 │     │                 │        │\n│  │ • Document      │     │ • Supabase      │     │ • OpenAI        │        │\n│  │   Processing    │     │ • PostgreSQL    │     │ • Gemini        │        │\n│  │ • Vector Store  │◄───►│ • PGVector      │◄───►│ • Anthropic     │        │\n│  │ • RAG Engine    │     │ • Redis Cache   │     │ • Ollama        │        │\n│  │ • Search        │     │ • File Storage  │     │ • Custom APIs   │        │\n│  └─────────────────┘     └─────────────────┘     └─────────────────┘        │\n│                                                                               │\n└─────────────────────────────────────────────────────────────────────────────────┘\n```\n\n## 🔧 Service Architecture\n\n### Core Services\n\n#### 1. Web Server (Port 8181)\n**Technology**: FastAPI + Socket.IO + Python\n**Responsibilities**:\n- RESTful API endpoints\n- Real-time WebSocket communications\n- Business logic orchestration\n- Authentication and authorization\n- Background task management\n\n```python\n# Service Structure\nsrc/server/\n├── api_routes/          # REST API endpoints\n├── services/            # Business logic\n├── middleware/          # Request processing\n├── utils/              # Helper functions\n└── main.py             # FastAPI application\n```\n\n#### 2. MCP Server (Port 8051)\n**Technology**: Lightweight HTTP + Python\n**Responsibilities**:\n- Model Context Protocol implementation\n- AI client integration hub\n- Tool execution and routing\n- Session management\n- Protocol translation\n\n```python\n# MCP Structure\nsrc/mcp_server/\n├── features/           # MCP tool implementations\n├── modules/            # Core MCP functionality\n├── utils/              # Protocol utilities\n└── mcp_server.py       # MCP application\n```\n\n#### 3. Agents Service (Port 8052)\n**Technology**: PydanticAI + Python\n**Responsibilities**:\n- AI agent orchestration\n- Specialized agent deployment\n- DeepConf confidence scoring\n- SCWT metrics collection\n- Advanced ML operations\n\n```python\n# Agents Structure\nsrc/agents/\n├── configs/            # Agent configurations\n├── orchestration/      # Agent management\n├── memory/             # Context and memory\n├── validation/         # Quality assurance\n└── server.py           # Agents service\n```\n\n#### 4. Web Interface (Port 3737)\n**Technology**: React + TypeScript + Vite\n**Responsibilities**:\n- User interface and experience\n- Real-time updates display\n- Configuration management\n- Interactive dashboards\n- Mobile-responsive design\n\n```typescript\n// Frontend Structure\nsrc/\n├── components/         # React components\n├── pages/             # Application pages\n├── services/          # API communication\n├── hooks/             # Custom React hooks\n└── contexts/          # State management\n```\n\n### Supporting Services\n\n#### 5. Validator Service (Port 8053)\n**Technology**: Python + External LLMs\n**Responsibilities**:\n- External validation and cross-checking\n- Quality assurance automation\n- Compliance monitoring\n- Independent verification\n\n### Database Layer\n\n#### Supabase (PostgreSQL + Extensions)\n**Components**:\n- **PostgreSQL**: Primary data storage\n- **PGVector**: Vector embeddings storage\n- **Row Level Security**: Data protection\n- **Real-time**: Live data updates\n- **Edge Functions**: Serverless compute\n\n```sql\n-- Key Tables\nSources              -- Knowledge sources\nDocuments            -- Processed content\nProjects             -- Project management\nTasks                -- Task tracking\nCredentials          -- Encrypted API keys\nSettings             -- Configuration\n```\n\n## 🔄 Data Flow Architecture\n\n### 1. Knowledge Ingestion Flow\n\n```mermaid\nsequenceDiagram\n    participant UI as Web UI\n    participant Server as Web Server\n    participant KB as Knowledge Base\n    participant DB as Database\n    participant Vector as Vector Store\n    \n    UI->>Server: Upload/Crawl Request\n    Server->>KB: Process Content\n    KB->>KB: Extract & Chunk\n    KB->>Vector: Generate Embeddings\n    Vector->>DB: Store Vectors\n    KB->>DB: Store Metadata\n    Server->>UI: Progress Updates (WebSocket)\n```\n\n### 2. RAG Query Flow\n\n```mermaid\nsequenceDiagram\n    participant Client as AI Client\n    participant MCP as MCP Server\n    participant Server as Web Server\n    participant KB as Knowledge Base\n    participant Agents as Agents Service\n    \n    Client->>MCP: RAG Query Tool\n    MCP->>Server: Query Request\n    Server->>KB: Search Knowledge\n    KB->>KB: Hybrid Search\n    KB->>Agents: Rerank Results (optional)\n    Agents->>KB: Ranked Results\n    KB->>Server: Final Results\n    Server->>MCP: Formatted Response\n    MCP->>Client: Tool Result\n```\n\n### 3. Agent Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant UI as Web UI\n    participant Server as Web Server\n    participant Agents as Agents Service\n    participant Memory as Memory System\n    participant Validator as Validator\n    \n    UI->>Server: Agent Task Request\n    Server->>Agents: Deploy Agent\n    Agents->>Memory: Load Context\n    Agents->>Agents: Execute Task\n    Agents->>Validator: Validate Output\n    Validator->>Agents: Validation Result\n    Agents->>Server: Task Result + Metrics\n    Server->>UI: Updates (WebSocket)\n```\n\n## 🧠 AI Agent System\n\n### Agent Categories\n\n#### Development Agents\n- **System Architect**: Architecture design and planning\n- **Code Implementer**: Zero-error code implementation\n- **Code Quality Reviewer**: Code review and validation\n- **Test Coverage Validator**: Test creation and coverage\n- **Performance Optimizer**: Performance analysis\n- **Security Auditor**: Security scanning and fixes\n- **Refactoring Specialist**: Code improvement\n\n#### Specialized Agents\n- **UI/UX Designer**: Interface design and usability\n- **Database Architect**: Data modeling and optimization\n- **API Design Architect**: API design and documentation\n- **Documentation Writer**: Technical documentation\n- **Error Handler**: Error detection and resolution\n- **Deployment Coordinator**: CI/CD and deployment\n\n#### Analysis Agents\n- **Strategic Planner**: Task breakdown and planning\n- **Data Analyst**: Data analysis and insights\n- **Configuration Manager**: System configuration\n- **Monitoring Agent**: System monitoring and alerts\n- **Integration Tester**: Integration testing\n- **Quality Assurance**: QA processes and validation\n\n### Agent Architecture\n\n```python\n# Base Agent Structure\nclass BaseAgent:\n    def __init__(self, config: AgentConfig):\n        self.name = config.name\n        self.model = config.model\n        self.prompt_template = config.prompt_template\n        self.tools = config.tools\n        self.memory = MemoryManager()\n        \n    async def execute(self, task: Task) -> AgentResult:\n        # Load context from memory\n        context = await self.memory.load_context(task)\n        \n        # Execute with PydanticAI\n        result = await self.model.run(\n            task.description,\n            context=context,\n            tools=self.tools\n        )\n        \n        # Store results in memory\n        await self.memory.store_result(result)\n        \n        return result\n```\n\n### DeepConf Confidence Engine\n\n**Purpose**: Provides reliability metrics for AI-generated content\n\n```python\n# Confidence Scoring Components\nclass DeepConfEngine:\n    def __init__(self):\n        self.uncertainty_estimator = UncertaintyEstimator()\n        self.consensus_validator = ConsensusValidator()\n        self.dynamic_scorer = DynamicScorer()\n        \n    async def score_confidence(self, result: AgentResult) -> float:\n        # Multiple validation approaches\n        uncertainty = self.uncertainty_estimator.estimate(result)\n        consensus = await self.consensus_validator.validate(result)\n        dynamic = self.dynamic_scorer.score(result)\n        \n        # Weighted combination\n        confidence = self.combine_scores(uncertainty, consensus, dynamic)\n        return confidence\n```\n\n## 📊 SCWT Metrics System\n\n**SCWT**: Specialized Code Quality, Workflow efficiency, Testing coverage, and Team collaboration\n\n### Metrics Categories\n\n#### Code Quality Metrics\n- Cyclomatic complexity\n- Code coverage percentage\n- Technical debt ratio\n- Security vulnerability count\n- Performance benchmarks\n\n#### Workflow Metrics\n- Task completion velocity\n- Agent utilization rates\n- Error resolution time\n- Documentation coverage\n- Integration success rate\n\n#### Testing Metrics\n- Unit test coverage\n- Integration test pass rate\n- E2E test reliability\n- Performance test results\n- Security test outcomes\n\n#### Team Metrics\n- Collaboration efficiency\n- Knowledge sharing rate\n- Onboarding time\n- User satisfaction scores\n- System adoption rate\n\n### Real-time Dashboard\n\n```typescript\n// SCWT Dashboard Component\ninterface SCWTMetrics {\n  codeQuality: {\n    coverage: number;\n    complexity: number;\n    techDebt: number;\n  };\n  workflow: {\n    velocity: number;\n    efficiency: number;\n    errorRate: number;\n  };\n  testing: {\n    unitCoverage: number;\n    integrationPass: number;\n    e2eReliability: number;\n  };\n  collaboration: {\n    teamEfficiency: number;\n    knowledgeSharing: number;\n    satisfaction: number;\n  };\n}\n```\n\n## 🔌 Integration Architecture\n\n### MCP (Model Context Protocol)\n\n**Purpose**: Standard protocol for AI client integration\n\n```python\n# MCP Tool Implementation\n@mcp_tool\nasync def perform_rag_query(\n    query: str,\n    match_count: int = 5,\n    filters: Optional[Dict] = None\n) -> RagResult:\n    \"\"\"Search knowledge base using advanced RAG strategies.\"\"\"\n    \n    # Execute hybrid search\n    results = await knowledge_service.search(\n        query=query,\n        match_count=match_count,\n        strategy=\"hybrid\",\n        filters=filters\n    )\n    \n    # Optional reranking\n    if reranking_enabled:\n        results = await reranking_service.rerank(results)\n    \n    return RagResult(\n        query=query,\n        results=results,\n        metadata={\n            \"strategy\": \"hybrid\",\n            \"reranked\": reranking_enabled,\n            \"confidence\": calculate_confidence(results)\n        }\n    )\n```\n\n### Available MCP Tools\n\n1. **archon:perform_rag_query** - Knowledge base search\n2. **archon:search_code_examples** - Code snippet search\n3. **archon:manage_project** - Project operations\n4. **archon:manage_task** - Task management\n5. **archon:get_available_sources** - List knowledge sources\n6. **archon:create_document** - Document creation\n7. **archon:update_document** - Document updates\n8. **archon:get_project_context** - Project context\n9. **archon:execute_agent** - Agent deployment\n10. **archon:get_scwt_metrics** - Quality metrics\n\n### WebSocket Architecture\n\n```typescript\n// Real-time Communication\ninterface WebSocketEvents {\n  // Progress tracking\n  'crawl_progress': CrawlProgress;\n  'project_creation_progress': ProjectProgress;\n  'agent_execution_progress': AgentProgress;\n  \n  // Data updates\n  'knowledge_update': KnowledgeUpdate;\n  'task_update': TaskUpdate;\n  'metrics_update': MetricsUpdate;\n  \n  // System events\n  'system_health': HealthStatus;\n  'error_notification': ErrorEvent;\n}\n```\n\n## 🗄️ Database Design\n\n### Core Schema\n\n```sql\n-- Knowledge Management\nCREATE TABLE sources (\n  id UUID PRIMARY KEY,\n  url TEXT,\n  type source_type,\n  status crawl_status,\n  metadata JSONB,\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ\n);\n\nCREATE TABLE documents (\n  id UUID PRIMARY KEY,\n  source_id UUID REFERENCES sources(id),\n  content TEXT,\n  embedding VECTOR(1536),\n  chunk_index INTEGER,\n  metadata JSONB,\n  created_at TIMESTAMPTZ\n);\n\n-- Project Management\nCREATE TABLE projects (\n  id UUID PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  config JSONB,\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ\n);\n\nCREATE TABLE tasks (\n  id UUID PRIMARY KEY,\n  project_id UUID REFERENCES projects(id),\n  title TEXT NOT NULL,\n  description TEXT,\n  status task_status,\n  priority task_priority,\n  metadata JSONB,\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ\n);\n\n-- Configuration\nCREATE TABLE credentials (\n  key TEXT PRIMARY KEY,\n  value TEXT NOT NULL, -- Encrypted\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ\n);\n\nCREATE TABLE settings (\n  key TEXT PRIMARY KEY,\n  value JSONB NOT NULL,\n  user_id UUID,\n  created_at TIMESTAMPTZ,\n  updated_at TIMESTAMPTZ\n);\n```\n\n### Vector Search Optimization\n\n```sql\n-- Vector similarity search index\nCREATE INDEX documents_embedding_idx \n  ON documents \n  USING ivfflat (embedding vector_cosine_ops) \n  WITH (lists = 100);\n\n-- Hybrid search support\nCREATE INDEX documents_content_search_idx \n  ON documents \n  USING gin(to_tsvector('english', content));\n\n-- Metadata filtering\nCREATE INDEX documents_metadata_idx \n  ON documents \n  USING gin(metadata);\n```\n\n## 🔒 Security Architecture\n\n### Authentication & Authorization\n\n```python\n# Security Layers\nclass SecurityManager:\n    def __init__(self):\n        self.auth_provider = SupabaseAuth()\n        self.encryption = EncryptionService()\n        self.rate_limiter = RateLimiter()\n        \n    async def authenticate(self, token: str) -> User:\n        # JWT validation with Supabase\n        return await self.auth_provider.verify_token(token)\n        \n    async def authorize(self, user: User, resource: str, action: str) -> bool:\n        # Role-based access control\n        return await self.check_permissions(user, resource, action)\n        \n    def encrypt_sensitive_data(self, data: str) -> str:\n        # Encrypt API keys and sensitive configuration\n        return self.encryption.encrypt(data)\n```\n\n### Data Protection\n\n- **Encryption at Rest**: All sensitive data encrypted in database\n- **Encryption in Transit**: TLS/SSL for all communications\n- **Row Level Security**: Supabase RLS for data isolation\n- **API Key Management**: Secure storage and rotation\n- **Input Validation**: Comprehensive data validation\n- **Rate Limiting**: Protection against abuse\n\n## 📈 Performance Architecture\n\n### Caching Strategy\n\n```python\n# Multi-layer caching\nclass CacheManager:\n    def __init__(self):\n        self.redis = Redis()  # Distributed cache\n        self.memory = MemoryCache()  # Local cache\n        self.vector_cache = VectorCache()  # Embedding cache\n        \n    async def get_with_fallback(self, key: str) -> Optional[Any]:\n        # Try memory first (fastest)\n        if value := self.memory.get(key):\n            return value\n            \n        # Then Redis (shared)\n        if value := await self.redis.get(key):\n            self.memory.set(key, value)\n            return value\n            \n        # Finally database (slowest)\n        return None\n```\n\n### Optimization Strategies\n\n- **Connection Pooling**: Database connection management\n- **Query Optimization**: Efficient database queries\n- **Lazy Loading**: Load data on demand\n- **Background Processing**: Async task execution\n- **CDN Integration**: Static asset delivery\n- **Compression**: Response compression\n- **Monitoring**: Performance metrics collection\n\n## 🚀 Deployment Architecture\n\n### Container Strategy\n\n```dockerfile\n# Multi-stage builds for optimization\nFROM python:3.12-slim as base\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    postgresql-client \\\n    && rm -rf /var/lib/apt/lists/*\n\nFROM base as deps\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nFROM deps as runtime\n# Copy application code\nCOPY src/ /app/src/\nWORKDIR /app\nCMD [\"uvicorn\", \"src.server.main:app\", \"--host\", \"0.0.0.0\"]\n```\n\n### Orchestration\n\n```yaml\n# docker-compose.yml\nservices:\n  archon-server:\n    build: ./python\n    environment:\n      - SUPABASE_URL=${SUPABASE_URL}\n      - SUPABASE_SERVICE_KEY=${SUPABASE_SERVICE_KEY}\n    networks:\n      - app-network\n    depends_on:\n      - postgres\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8181/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n```\n\n### Scaling Considerations\n\n- **Horizontal Scaling**: Multiple service instances\n- **Load Balancing**: Request distribution\n- **Database Scaling**: Read replicas and sharding\n- **Caching Layers**: Redis clustering\n- **CDN Integration**: Global content delivery\n- **Monitoring**: Health checks and metrics\n\n## 🔮 Future Architecture\n\n### Planned Enhancements\n\n- **Kubernetes Support**: Container orchestration\n- **GraphQL API**: Flexible data querying\n- **Event Sourcing**: Complete audit trails\n- **CQRS Pattern**: Command/Query separation\n- **Microservice Mesh**: Service communication\n- **AI Model Registry**: Custom model management\n- **Plugin Architecture**: Third-party extensions\n- **Multi-tenant Support**: Organization isolation\n\n---\n\n**This architecture documentation is living and evolves with the system. For the latest updates, check our [GitHub repository](https://github.com/coleam00/archon).**